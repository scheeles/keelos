syntax = "proto3";

package keel.v1;

service NodeService {
  // Get system health and status
  rpc GetStatus (GetStatusRequest) returns (GetStatusResponse);
  
  // Reboot the node (protected)
  rpc Reboot (RebootRequest) returns (RebootResponse);

  // Install an OS update to the inactive partition
  rpc InstallUpdate (InstallUpdateRequest) returns (stream UpdateProgress);
  
  // Schedule an update for a future time
  rpc ScheduleUpdate (ScheduleUpdateRequest) returns (ScheduleUpdateResponse);
  
  // Get current update schedule
  rpc GetUpdateSchedule (GetUpdateScheduleRequest) returns (GetUpdateScheduleResponse);
  
  // Cancel scheduled update
  rpc CancelScheduledUpdate (CancelScheduledUpdateRequest) returns (CancelScheduledUpdateResponse);
  
  // Get system health status
  rpc GetHealth (GetHealthRequest) returns (GetHealthResponse);
  
  // Manually trigger rollback
  rpc TriggerRollback (TriggerRollbackRequest) returns (TriggerRollbackResponse);
  
  // Get rollback history
  rpc GetRollbackHistory (GetRollbackHistoryRequest) returns (GetRollbackHistoryResponse);
  
  // Bootstrap certificate initialization (unauthenticated)
  rpc InitBootstrap (InitBootstrapRequest) returns (InitBootstrapResponse);
  
  // Rotate operational certificate (triggers new K8s CSR)
  rpc RotateCertificate (RotateCertificateRequest) returns (RotateCertificateResponse);
  
  // Bootstrap Kubernetes cluster joining
  rpc BootstrapKubernetes (BootstrapKubernetesRequest) returns (BootstrapKubernetesResponse);
  
  // Get Kubernetes bootstrap status
  rpc GetBootstrapStatus (GetBootstrapStatusRequest) returns (GetBootstrapStatusResponse);
  
  // Configure network interfaces and DNS
  rpc ConfigureNetwork (ConfigureNetworkRequest) returns (ConfigureNetworkResponse);
  
  // Get current network configuration
  rpc GetNetworkConfig (GetNetworkConfigRequest) returns (GetNetworkConfigResponse);
  
  // Get runtime network status (link state, IP addresses, statistics)
  rpc GetNetworkStatus (GetNetworkStatusRequest) returns (GetNetworkStatusResponse);
}

message InstallUpdateRequest {
  // Source of the SquashFS image (URL or local path)
  string source_url = 1;
  // Expected SHA256 checksum (optional)
  string expected_sha256 = 2;
  
  // Delta update support
  bool is_delta = 3;
  bool fallback_to_full = 4;  // If delta fails, try full image
  string full_image_url = 5;   // URL for fallback full image
}

message UpdateProgress {
  uint32 percentage = 1;
  string message = 2;
  bool success = 3;
  // Optional: Estimated time remaining in seconds
  uint32 eta_seconds = 4;
  // Optional: Download speed in bytes/sec
  uint64 download_speed_bps = 5;
  
  // Delta-specific info
  string phase = 6;  // "downloading", "patching", "verifying"
  uint64 bytes_saved = 7;  // Bandwidth saved vs full download
}

message GetStatusRequest {}

message GetStatusResponse {
  string hostname = 1;
  string kernel_version = 2;
  string os_version = 3;
  float uptime_seconds = 4;
}

message RebootRequest {
  // Reason for reboot (audit log)
  string reason = 1;
}

message RebootResponse {
  bool scheduled = 1;
}

// Scheduling messages

message ScheduleUpdateRequest {
  string source_url = 1;
  string expected_sha256 = 2;
  
  // Optional: Schedule for specific time (RFC3339 format)
  string scheduled_at = 3;
  
  // Optional: Maintenance window duration in seconds
  uint32 maintenance_window_secs = 4;
  
  // Optional: Enable auto-rollback on failure
  bool enable_auto_rollback = 5;
  
  // Optional: Health check timeout in seconds (default: 300)
  uint32 health_check_timeout_secs = 6;
  
  // Optional: Pre-update hook command
  string pre_update_hook = 7;
  
  // Optional: Post-update hook command
  string post_update_hook = 8;
  
  // Delta update support
  // Delta update support
  bool is_delta = 9;
  bool fallback_to_full = 10;
  string full_image_url = 11;
}

message ScheduleUpdateResponse {
  string schedule_id = 1;
  string status = 2;
  string scheduled_at = 3;
}

message GetUpdateScheduleRequest {}

message GetUpdateScheduleResponse {
  repeated UpdateSchedule schedules = 1;
}

message UpdateSchedule {
  string id = 1;
  string source_url = 2;
  string expected_sha256 = 3;
  string scheduled_at = 4;
  string status = 5; // pending, running, completed, failed, cancelled
  bool enable_auto_rollback = 6;
  string created_at = 7;
}

message CancelScheduledUpdateRequest {
  string schedule_id = 1;
}

message CancelScheduledUpdateResponse {
  bool success = 1;
  string message = 2;
}

// Health check messages

message GetHealthRequest {}

message GetHealthResponse {
  string status = 1; // "healthy", "degraded", "unhealthy"
  repeated HealthCheckResult checks = 2;
  string last_update_time = 3;
}

message HealthCheckResult {
  string name = 1;
  string status = 2; // "pass", "fail", "unknown"
  string message = 3;
  uint64 duration_ms = 4;
}

// Rollback messages

message TriggerRollbackRequest {
  string reason = 1;
}

message TriggerRollbackResponse {
  bool success = 1;
  string message = 2;
}

message GetRollbackHistoryRequest {}

message GetRollbackHistoryResponse {
  repeated RollbackEvent events = 1;
}

message RollbackEvent {
  string timestamp = 1;
  string reason = 2;
  string from_partition = 3;
  string to_partition = 4;
  bool automatic = 5;
}

// Kubernetes Bootstrap messages

message BootstrapKubernetesRequest {
  // Kubernetes API server endpoint (e.g., "https://k8s.example.com:6443")
  string api_server_endpoint = 1;
  
  // Bootstrap token for TLS bootstrapping (format: <token-id>.<token-secret>)
  // Optional if kubeconfig is provided
  string bootstrap_token = 2;
  
  // Cluster CA certificate in PEM format
  // Required for token-based auth, optional if kubeconfig contains CA
  string ca_cert_pem = 3;
  
  // Full kubeconfig content as bytes (alternative to token-based auth)
  // If provided, bypasses token authentication
  bytes kubeconfig = 4;
  
  // Override node name (default: hostname)
  string node_name = 5;
}

message BootstrapKubernetesResponse {
  bool success = 1;
  string message = 2;
  // Path where kubeconfig was written
  string kubeconfig_path = 3;
}

message GetBootstrapStatusRequest {}

message GetBootstrapStatusResponse {
  // Whether node has been bootstrapped to a cluster
  bool is_bootstrapped = 1;
  
  // API server endpoint if bootstrapped
  string api_server_endpoint = 2;
  
  // Node name in the cluster
  string node_name = 3;
  
  // Path to kubeconfig file
  string kubeconfig_path = 4;
  
  // Bootstrap timestamp (RFC3339)
  string bootstrapped_at = 5;
}

// Bootstrap certificate initialization messages
message InitBootstrapRequest {
  // Client's self-signed bootstrap certificate in PEM format (24h validity)  
  string client_cert_pem = 1;
}

message InitBootstrapResponse {
  bool success = 1;
  string message = 2;
}

// Certificate rotation messages
message RotateCertificateRequest {
  // Force rotation even if current cert is valid
  bool force = 1;
}


message RotateCertificateResponse {
  bool success = 1;
  string message = 2;
  // Path to new certificate
  string cert_path = 3;
  // Certificate expiry time (RFC3339)
  string expires_at = 4;
}

// Network Management messages

message ConfigureNetworkRequest {
  // Network interface configurations
  repeated NetworkInterface interfaces = 1;
  
  // DNS configuration
  DNSConfig dns = 2;
  
  // Custom routes
  repeated NetworkRoute routes = 3;
  
  // Optional: Reboot after applying configuration
  bool auto_reboot = 4;
}

message ConfigureNetworkResponse {
  bool success = 1;
  string message = 2;
  // Whether reboot is required for changes to take effect
  bool reboot_required = 3;
}

message GetNetworkConfigRequest {}

message GetNetworkConfigResponse {
  repeated NetworkInterface interfaces = 1;
  DNSConfig dns = 2;
  repeated NetworkRoute routes = 3;
}

message GetNetworkStatusRequest {}

message GetNetworkStatusResponse {
  repeated InterfaceStatus interfaces = 1;
}

message NetworkInterface {
  // Interface name (e.g., "eth0", "bond0", "eth0.100")
  string name = 1;
  
  // Configuration type
  oneof config {
    DHCPConfig dhcp = 2;
    StaticConfig static = 3;
    VLANConfig vlan = 4;
    BondConfig bond = 5;
  }
}

message DHCPConfig {
  // Whether to use DHCP for this interface
  bool enabled = 1;
}

message StaticConfig {
  // IPv4 address with CIDR notation (e.g., "192.168.1.100/24")
  string ipv4_address = 1;
  
  // Gateway IP address
  string gateway = 2;
  
  // MTU (optional, default 1500)
  uint32 mtu = 3;
}

message VLANConfig {
  // Parent interface name
  string parent = 1;
  
  // VLAN ID (1-4094)
  uint32 vlan_id = 2;
  
  // IP configuration for the VLAN interface
  oneof ip_config {
    DHCPConfig dhcp = 3;
    StaticConfig static = 4;
  }
}

message BondConfig {
  // Bonding mode ("802.3ad", "active-backup", "balance-rr")
  string mode = 1;
  
  // Slave interfaces
  repeated string slaves = 2;
  
  // IP configuration for the bond interface
  oneof ip_config {
    DHCPConfig dhcp = 3;
    StaticConfig static = 4;
  }
}

message DNSConfig {
  // DNS nameserver IP addresses
  repeated string nameservers = 1;
  
  // DNS search domains
  repeated string search_domains = 2;
}

message NetworkRoute {
  // Destination network in CIDR notation (e.g., "10.0.0.0/8")
  string destination = 1;
  
  // Gateway IP address
  string gateway = 2;
  
  // Optional: Metric/priority
  uint32 metric = 3;
}

message InterfaceStatus {
  // Interface name
  string name = 1;
  
  // Link state (up, down, unknown)
  string state = 2;
  
  // IPv4 addresses
  repeated string ipv4_addresses = 3;
  
  // MAC address
  string mac_address = 4;
  
  // MTU
  uint32 mtu = 5;
  
  // Statistics
  InterfaceStatistics statistics = 6;
}

message InterfaceStatistics {
  // Received bytes
  uint64 rx_bytes = 1;
  
  // Transmitted bytes
  uint64 tx_bytes = 2;
  
  // Received packets
  uint64 rx_packets = 3;
  
  // Transmitted packets
  uint64 tx_packets = 4;
  
  // Receive errors
  uint64 rx_errors = 5;
  
  // Transmit errors
  uint64 tx_errors = 6;
}
